# -*- coding: utf-8 -*-
"""NQueens_latest.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ebt4nLTk_I55x5RYkDNPI8xxYJjLWGWz
"""

import math
inf8 = math.inf

class QueenGraph:
  def __init__(self, N):
    self.d={}          ##dictionary={variable:[domain]}
    for i in range(N):
        self.d[i]=list(range(N))
    self.c=[]          ##binary constaints[(x1,x2),(x1,x3)...]
    for i in range(N):
      for j in range(i,N):
        if i!=j:
          self.c.append(tuple((i,j)))
    self.count=0       ##solution count
    self.btrack_steps=0##no. of backtracking steps

def inequalityConstraint2(q1, q2, q1_index, q2_index):
  if q1!=q2 and abs(q1-q2)!=abs(q1_index-q2_index):
    return True
  else:
    return False
    
def getOtherNeighbors(x, csp, y):
  neighbors=[]
  for i in csp.c:
    if x in i and y not in i:
      q1=i[0]
      q2=i[1]
      if x==q1:
        neighbors.append(q2)
      elif x==q2:
        neighbors.append(q1)
  return neighbors

def revise(csp, q1, q2):
  revised=False
  for i in csp.d[q1]:
    for j in csp.d[q2]:
      if inequalityConstraint2(i,j,q1,q2):
        break
    else:
      csp.d[q1].remove(i)
      revised=True
  return revised

def ac3(q, csp):
  while len(q) != 0:
    tupl=q[0]
    q.remove(tupl)
    q1=tupl[0]
    q2=tupl[1]
    if revise(csp, q1, q2):
      if len(csp.d[q1])==0:
        return False
      for n in getOtherNeighbors(q1,csp,q2):
        q.append(tuple(n,q1))
  return True

def forwardCheck(csp, var, value, dom):
  for i in csp.c:
    if var in i:
      if var==i[0]:
        other=i[1]
      else:
        other=i[0]
      
      for j in dom[other]:
        if not inequalityConstraint2(value,j,var,other):
          dom[other].remove(j)
      else:
        if len(dom[other])==0:
          return False
  else:
    return True

import copy

def consistent(var, value, assignment, csp):
  for i in csp.c:
    if var in i:
      if var==i[0]:
        nhbr=i[1]
      else:
        nhbr=i[0]
      if not inequalityConstraint2(value,assignment[nhbr],var,nhbr):
        return False
  else:
    return True
    
def complete(assign):
  for i in assign:
    if i==inf8:
      return False
  else:
    return True

def getUnassignedVariable_Linear(csp):
  for i in csp.x:
    if i==inf8:
      return i
    
def getUnassignedVariable_MRV(assignment, csp):
  min_domain=inf8
  min_variable=inf8
  for q in range(len(csp.d)):
    if assignment[q]==inf8 and len(csp.d[q])<min_domain:
      min_domain=len(csp.d[q])
      min_variable=q
  return min_variable

solution=[]##has all solutions in it
#btrack_steps=0
#count=0

##backtrack for MAC
def backtracking_search_MAC(csp,r_file):
  solution.clear()
  assign=[inf8]*len(csp.d)
  return backtrack_MAC(assign,csp,r_file)

def backtrack_MAC(assignment,csp,r_file):
  if(len(solution))>=2*len(csp.d):
    return
  if complete(assignment):
    csp.count+=1
    appendSolution(assignment, r_file, csp.count)
    r=assignment.copy()
    solution.append(r)
    return
  var=getUnassignedVariable_MRV(assignment, csp)
  for value in csp.d[var]:
    if consistent(var,value,assignment,csp):
      assignment[var]=value
      
      ##Maintaining Arc Consistency
      q = []
      for i in csp.c:
        if var in i and i[1]==var and assignment[i[0]]==inf8:
          q.append(i)
      inference=ac3(q, csp)    
      
      if inference:
        backtrack_MAC(assignment,csp,r_file)
        csp.btrack_steps+=1
    assignment[var]=inf8
  return

##backtrack for FOR
def backtracking_search_FOR(csp,r_file):
  solution.clear()
  assign=[inf8]*len(csp.d)
  return backtrack_FOR(assign,csp,csp.d,r_file)

def backtrack_FOR(assignment,csp,dom,r_file):
  if(len(solution))>=2*len(csp.d):
    return
  if complete(assignment):
    csp.count+=1
    appendSolution(assignment, r_file, csp.count)
    r=assignment.copy()
    solution.append(r)
    return
  var=getUnassignedVariable_MRV(assignment, csp)
  legal=copy.deepcopy(dom)
  for value in legal[var]:
    if consistent(var,value,assignment,csp):
      assignment[var]=value
      
      ##ForwardChecking
      inference=forwardCheck(csp,var,value,dom)
      
      if inference:
        backtrack_FOR(assignment,csp,dom,r_file)
        csp.btrack_steps+=1
      dom=copy.deepcopy(legal)
    assignment[var]=inf8
  return

def printCSP(csp, c_file):
  f= open("{}.txt".format(c_file),"w+")
  f.write('-----{}-Queens Problem-----\r\n'.format(len(csp.d)))
  f.write('Our VARIABLES and their DOMAIN\n')
  for v,dom in csp.d.items():
    f.write('Q{} = {}\n'.format(v,set(dom)))
  f.write('\nCONSTRAINTS\n')
  for constr in csp.c:
    f.write('Q{0}!=Q{1} and |Q{0}-Q{1}|!={2}\n'.format(constr[0],constr[1],abs(constr[0]-constr[1])))
  f.close()

def openRfile(csp, r_file, algo):
  f= open("{}.txt".format(r_file),"w+")
  f.write('-----SOLUTIONS to {}-Queens Problem-----Algo::{}\r\n'.format(len(csp.d), algo))
  f.close()
  
def appendSolution(solution, r_file, num):
  f= open("{}.txt".format(r_file),"a+")
  f.write('Solution {}: {}\n'.format(num,solution))
  for i in solution:
    for j in range(len(solution)):
      if j==i:
        f.write('1')
      else:
        f.write('0')
    f.write('\n')
  f.write('\n\n')
  f.close()
  
def appendFacts(count, time_taken, backtrack_steps):
  f= open("{}.txt".format(r_file),"a+")
  f.write('No. of Solutions found: {}\n'.format(count))
  f.write('Time taken to obtain solutions: {} seconds\n'.format(time_taken))
  f.write('Total no. of backtracking steps: {}\n'.format(backtrack_steps))
  f.close()

import time
import sys
args=sys.argv
algo=args[1]
#algo='MAC'
n=int(args[2])
#n=15
c_file=args[3]
#c_file="cfile"
r_file=args[4]
#r_file="rfile"

start_time = time.time()
csp=QueenGraph(n)
printCSP(csp, c_file)

openRfile(csp, r_file, algo)
if algo=='FOR':
  backtracking_search_FOR(csp,r_file)
elif algo=='MAC':
  backtracking_search_MAC(csp,r_file)
end_time=time.time()
appendFacts(csp.count, end_time - start_time, csp.btrack_steps)

#print(csp.btrack_steps)
#print(csp.count)
#print(len(solution))
#print(solution)
#print('{} seconds'.format(end_time - start_time))